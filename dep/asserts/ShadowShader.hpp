//GENERATED BY GLSL_GEN
#ifndef SHADOWSHADER_HPP
#define SHADOWSHADER_HPP
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <fstream>
#include <sstream>
#include <GL/gl3w.h>
namespace asserts {
class ShadowShader {
private:
	GLuint program_{0};
public:
	void Use() const { glUseProgram(program_); }
	GLuint Get() const { return program_; }
	ShadowShader() = default;
	~ShadowShader(){ if(program_ != 0) glDeleteProgram(program_); }
	ShadowShader(const ShadowShader &) = delete;
	ShadowShader& operator= (const ShadowShader &) = delete;
private:
	GLint unif_uLightMatrix;
public:
	void Initialize() {
		GLuint shader;
		program_ = glCreateProgram();
		const char *GL_FRAGMENT_SHADER_src = "#version 450 core\n\nout float FragColor;\nin vec4 vPosition;\n\nconst float kEsmC = 60.0f;\n\nvoid main()\n{\n	float depth = vPosition.z / vPosition.w;\n	depth = depth * 0.5f + 0.5f;\n	\n	FragColor = depth * kEsmC;\n}\n";
		shader = glCreateShader(GL_FRAGMENT_SHADER);
		glShaderSource(shader, 1, &GL_FRAGMENT_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		const char *GL_VERTEX_SHADER_src = "#version 450 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\nlayout (location = 2) in vec2 aTexcoords;\n\nout vec4 vPosition;\nuniform mat4 uLightMatrix;\n\nvoid main()\n{\n	gl_Position = uLightMatrix * vec4(aPos, 1.0f);\n	vPosition = gl_Position;\n}\n";
		shader = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(shader, 1, &GL_VERTEX_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		unif_uLightMatrix = glGetUniformLocation(program_, "uLightMatrix");
	}
	void SetULightMatrix(const glm::mat4 &v) { glProgramUniformMatrix4fv(program_, unif_uLightMatrix, 1, GL_FALSE, glm::value_ptr(v)); }
	GLint GetULightMatrixLocation() const { return unif_uLightMatrix; };
};
}
#endif
