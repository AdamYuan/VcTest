//GENERATED BY GLSL_GEN
#ifndef GBUFFERSHADER_HPP
#define GBUFFERSHADER_HPP
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <fstream>
#include <sstream>
#include <GL/gl3w.h>
namespace asserts {
class GBufferShader {
private:
	GLuint program_{0};
public:
	void Use() const { glUseProgram(program_); }
	GLuint Get() const { return program_; }
	GBufferShader() = default;
	~GBufferShader(){ if(program_ != 0) glDeleteProgram(program_); }
	GBufferShader(const GBufferShader &) = delete;
	GBufferShader& operator= (const GBufferShader &) = delete;
private:
	GLint unif_uProjection;
	GLint unif_uView;
public:
	void Initialize() {
		GLuint shader;
		program_ = glCreateProgram();
		const char *GL_FRAGMENT_SHADER_src = "#version 450 core\n\nlayout (location = 0) out vec4 GPosition;\nlayout (location = 1) out vec3 GNormal;\nlayout (location = 2) out vec4 GAlbedo;\n\nin vec2 vTexcoords;\nin vec3 vFragPos, vNormal;\n\nlayout (binding = 0) uniform sampler2D uDiffuseTexture;\n\nconst float kNear = 0.1f, kFar = 100.0f; \nfloat LinearizeDepth(float depth) \n{\n    float z = depth * 2.0 - 1.0; // back to NDC \n    return (2.0 * kNear * kFar) / (kFar + kNear - z * (kFar - kNear));\n}\n\nvoid main()\n{\n	vec4 color4 = texture(uDiffuseTexture, vTexcoords);\n	if(color4.a < 0.1f)\n		discard;\n\n	GPosition = vec4(vFragPos, LinearizeDepth(gl_FragCoord.z));\n	GNormal = normalize(vNormal) * 0.5f + 0.5f;\n	GAlbedo = vec4(color4.rgb, 1.0f);\n}\n";
		shader = glCreateShader(GL_FRAGMENT_SHADER);
		glShaderSource(shader, 1, &GL_FRAGMENT_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		const char *GL_VERTEX_SHADER_src = "#version 450 core\n\nlayout (location = 0) in vec3 aPosition;\nlayout (location = 1) in vec3 aNormal;\nlayout (location = 2) in vec2 aTexcoords;\n\nout vec2 vTexcoords;\nout vec3 vFragPos, vNormal;\n\nuniform mat4 uProjection, uView;\n\nvoid main()\n{\n	vFragPos = aPosition;\n	vTexcoords = aTexcoords;\n	vNormal = aNormal;\n	gl_Position = uProjection * uView * vec4(aPosition, 1.0f);\n}\n";
		shader = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(shader, 1, &GL_VERTEX_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		unif_uProjection = glGetUniformLocation(program_, "uProjection");
		unif_uView = glGetUniformLocation(program_, "uView");
	}
	void SetUProjection(const glm::mat4 &v) { glProgramUniformMatrix4fv(program_, unif_uProjection, 1, GL_FALSE, glm::value_ptr(v)); }
	GLint GetUProjectionLocation() const { return unif_uProjection; };
	void SetUView(const glm::mat4 &v) { glProgramUniformMatrix4fv(program_, unif_uView, 1, GL_FALSE, glm::value_ptr(v)); }
	GLint GetUViewLocation() const { return unif_uView; };
};
}
#endif
