//GENERATED BY GLSL_GEN
#ifndef VOXELDIRECTLIGHTSHADER_HPP
#define VOXELDIRECTLIGHTSHADER_HPP
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <fstream>
#include <sstream>
#include <GL/gl3w.h>
namespace asserts {
class VoxelDirectLightShader {
private:
	GLuint program_{0};
public:
	void Use() const { glUseProgram(program_); }
	GLuint Get() const { return program_; }
	VoxelDirectLightShader() = default;
	~VoxelDirectLightShader(){ if(program_ != 0) glDeleteProgram(program_); }
	VoxelDirectLightShader(const VoxelDirectLightShader &) = delete;
	VoxelDirectLightShader& operator= (const VoxelDirectLightShader &) = delete;
private:
	GLint unif_uVoxelDimension;
	GLint unif_uLightMatrix;
	GLint unif_uLightDir;
	GLint unif_uVoxelGridRangeMin;
	GLint unif_uVoxelWorldSize;
public:
	void Initialize() {
		GLuint shader;
		program_ = glCreateProgram();
		const char *GL_COMPUTE_SHADER_src = "#version 450 core\nlayout (local_size_x = 3, local_size_y = 3, local_size_z = 3) in;\n\nlayout (binding = 0, rgba16) uniform writeonly image3D uVoxelRadiance;\n\nlayout (binding = 0) uniform sampler3D uVoxelAlbedo;\nlayout (binding = 1) uniform sampler3D uVoxelNormal;\nlayout (binding = 2) uniform sampler2D uShadowMap;\n\nuniform ivec3 uVoxelDimension;\nuniform mat4 uLightMatrix;\nuniform vec3 uLightDir, uVoxelGridRangeMin;\nuniform float uVoxelWorldSize;\n\nconst float kEsmC = 60.0f;\n\nfloat SM_GetVisibility(in sampler2D shadow_map, in vec4 lightspace_pos)\n{\n	vec3 proj_coords = lightspace_pos.xyz / lightspace_pos.w;\n	proj_coords = proj_coords * 0.5f + 0.5f;\n\n	float current_depth = proj_coords.z;\n	float occluder = texture(shadow_map, proj_coords.xy).r;\n	return clamp(exp((occluder - kEsmC * current_depth)), 0.0f, 1.0f);\n}\n\nfloat SM_GetVisibility(in sampler2D shadow_map, in vec3 position, in mat4 light_matrix)\n{\n	vec4 lightspace_frag_pos = light_matrix * vec4(position, 1.0f);\n	return SM_GetVisibility(shadow_map, lightspace_frag_pos);\n}\n\nvoid main()\n{\n	if(\n			gl_GlobalInvocationID.x >= uVoxelDimension.x || \n			gl_GlobalInvocationID.y >= uVoxelDimension.y ||\n			gl_GlobalInvocationID.z >= uVoxelDimension.z) \n		return;\n\n	ivec3 write_pos = ivec3(gl_GlobalInvocationID);\n\n	vec4 albedo = texelFetch(uVoxelAlbedo, write_pos, 0);\n	if(albedo.a < 0.001f)\n		return;\n\n	vec3 normal = texelFetch(uVoxelNormal, write_pos, 0).rgb * 2.0f - 1.0f;\n	vec3 w = normal * normal;\n	vec3 d = -uLightDir;\n	if(normal.x > 0) d.x = max(d.x, 0.0f); else d.x = max(-d.x, 0.0f);\n	if(normal.y > 0) d.y = max(d.y, 0.0f); else d.y = max(-d.y, 0.0f);\n	if(normal.z > 0) d.z = max(d.z, 0.0f); else d.z = max(-d.z, 0.0f);\n\n	float v = dot(w, d);\n\n	vec3 world_pos = uVoxelGridRangeMin + (vec3(write_pos) + normal) * uVoxelWorldSize;\n	float direct_light = v * SM_GetVisibility(uShadowMap, world_pos + vec3(uVoxelWorldSize / 2.0f), uLightMatrix);\n\n	imageStore(uVoxelRadiance, write_pos, vec4(albedo.rgb * direct_light, 1.0f));\n}\n";
		shader = glCreateShader(GL_COMPUTE_SHADER);
		glShaderSource(shader, 1, &GL_COMPUTE_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		unif_uVoxelDimension = glGetUniformLocation(program_, "uVoxelDimension");
		unif_uLightMatrix = glGetUniformLocation(program_, "uLightMatrix");
		unif_uLightDir = glGetUniformLocation(program_, "uLightDir");
		unif_uVoxelGridRangeMin = glGetUniformLocation(program_, "uVoxelGridRangeMin");
		unif_uVoxelWorldSize = glGetUniformLocation(program_, "uVoxelWorldSize");
	}
	void SetUVoxelDimension(const glm::ivec3 &v) { glProgramUniform3iv(program_, unif_uVoxelDimension, 1, glm::value_ptr(v)); }
	GLint GetUVoxelDimensionLocation() const { return unif_uVoxelDimension; };
	void SetULightMatrix(const glm::mat4 &v) { glProgramUniformMatrix4fv(program_, unif_uLightMatrix, 1, GL_FALSE, glm::value_ptr(v)); }
	GLint GetULightMatrixLocation() const { return unif_uLightMatrix; };
	void SetULightDir(const glm::vec3 &v) { glProgramUniform3fv(program_, unif_uLightDir, 1, glm::value_ptr(v)); }
	GLint GetULightDirLocation() const { return unif_uLightDir; };
	void SetUVoxelGridRangeMin(const glm::vec3 &v) { glProgramUniform3fv(program_, unif_uVoxelGridRangeMin, 1, glm::value_ptr(v)); }
	GLint GetUVoxelGridRangeMinLocation() const { return unif_uVoxelGridRangeMin; };
	void SetUVoxelWorldSize(GLfloat v) { glProgramUniform1f(program_, unif_uVoxelWorldSize, v); }
	GLint GetUVoxelWorldSizeLocation() const { return unif_uVoxelWorldSize; };
};
}
#endif
