//GENERATED BY GLSL_GEN
#ifndef SHADOWBLURSHADER_HPP
#define SHADOWBLURSHADER_HPP
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <fstream>
#include <sstream>
#include <GL/gl3w.h>
namespace asserts {
class ShadowBlurShader {
private:
	GLuint program_{0};
public:
	void Use() const { glUseProgram(program_); }
	GLuint Get() const { return program_; }
	ShadowBlurShader() = default;
	~ShadowBlurShader(){ if(program_ != 0) glDeleteProgram(program_); }
	ShadowBlurShader(const ShadowBlurShader &) = delete;
	ShadowBlurShader& operator= (const ShadowBlurShader &) = delete;
private:
	GLint unif_uDirection;
public:
	void Initialize() {
		GLuint shader;
		program_ = glCreateProgram();
		const char *GL_VERTEX_SHADER_src = "#version 450 core\n\nlayout (location = 0) in vec2 aPosition;\nlayout (location = 1) in vec2 aTexcoords;\n\nout vec2 vTexcoords;\n\nvoid main()\n{\n	gl_Position = vec4(aPosition, 1.0, 1.0);\n	vTexcoords = aTexcoords;\n}\n";
		shader = glCreateShader(GL_VERTEX_SHADER);
		glShaderSource(shader, 1, &GL_VERTEX_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		const char *GL_FRAGMENT_SHADER_src = "//http://www.klayge.org/2013/10/07/%E5%88%87%E6%8D%A2%E5%88%B0esm/\n#version 450 core\n\nin vec2 vTexcoords;\nlayout (binding = 1) uniform sampler2D uShadowMap;\nuniform vec2 uDirection;\n\nout float FragColor;\n\nconst float kKernels[5] = {0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216};\n\nvoid main()\n{\n	float result = 0.0f;\n	vec2 texel_size = vec2(1.0f) / vec2(textureSize(uShadowMap, 0));\n\n	float c = texture(uShadowMap, vTexcoords).x, cc;\n	vec2 c_coord;\n	for(int i = 1; i <= 4; ++i)\n	{\n		c_coord = vTexcoords + texel_size * uDirection * float(i);\n		cc = texture(uShadowMap, c_coord).x;\n		result += kKernels[i] * exp(cc - c);\n\n		c_coord = vTexcoords - texel_size * uDirection * float(i);\n		cc = texture(uShadowMap, c_coord).x;\n		result += kKernels[i] * exp(cc - c);\n	}\n\n	FragColor = c + log(kKernels[0] + result);\n}\n";
		shader = glCreateShader(GL_FRAGMENT_SHADER);
		glShaderSource(shader, 1, &GL_FRAGMENT_SHADER_src, nullptr);
		glCompileShader(shader);
		glAttachShader(program_, shader);
		glLinkProgram(program_);
		glDeleteShader(shader);
		unif_uDirection = glGetUniformLocation(program_, "uDirection");
	}
	void SetUDirection(const glm::vec2 &v) { glProgramUniform2fv(program_, unif_uDirection, 1, glm::value_ptr(v)); }
	GLint GetUDirectionLocation() const { return unif_uDirection; };
};
}
#endif
